<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Task Manager</title>
    <link href="https://cdn.jsdelivr.net/npm/fullcalendar@5.10.1/main.min.css" rel="stylesheet" />
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/fullcalendar@5.10.1/main.min.js"></script>
</head>
<body class="bg-gray-100 text-gray-800">
    <div class="container mx-auto p-6">
        <h1 class="text-3xl font-bold mb-6">Task Sphere</h1>     
        <div class="flex items-center justify-between mb-4">
            <div class="flex items-center">
                <span id="connectionStatus" class="px-3 py-1 bg-red-500 text-white rounded mr-2">Offline</span>
                <button id="syncButton" class="px-4 py-2 bg-purple-500 text-white rounded mr-2">Sync</button>
                <button onclick="openLoginModal()" class="px-4 py-2 bg-gray-800 text-white rounded">Login</button>
                <span id="userStatus" class="ml-2 text-gray-600">Not logged in</span>
            </div>
        </div>
        <div class="container mx-auto p-4 space-y-6">
            <div id="calendarView" class="view">
                <div id="calendar" class="my-4"></div>
            </div>
            <div id="tasksView" class="view">
                <h2 class="text-2xl font-semibold mb-4">Task List</h2>
                <div id="tasksContainer" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4"></div>
            </div>
        </div>
    </div>

    <!-- Login Modal -->
    <div id="loginModal" class="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center hidden z-50">
        <div class="bg-white p-6 rounded-lg shadow-lg">
            <h2 class="text-xl font-semibold mb-4">Login</h2>
            <input id="emailInput" type="text" placeholder="Email" class="w-full mb-2 p-2 border rounded">
            <input id="passwordInput" type="password" placeholder="Password" class="w-full mb-2 p-2 border rounded">
            <div class="flex justify-end">
                <button onclick="closeLoginModal()" class="px-4 py-2 bg-red-500 text-white rounded">Cancel</button>
                <button onclick="loginUser()" class="px-4 py-2 bg-blue-500 text-white rounded ml-2">Login</button>
            </div>
        </div>
    </div>
    <script>
        
document.addEventListener("DOMContentLoaded", () => {
    const apiUrl = "http://localhost:3000";
    const wsUrl = "ws://localhost:8080";

    let socket;
    let localTasks = JSON.parse(localStorage.getItem("tasks")) || [];
    let authToken = localStorage.getItem("sessionToken");
    let currentUser = localStorage.getItem("userId");
    let calendar;

    const connectionStatus = document.getElementById("connectionStatus");
    const syncButton = document.getElementById("syncButton");
    const tasksContainer = document.getElementById("tasksContainer");
    const userStatus = document.getElementById("userStatus");

    function formatDateUTC(date) {
        if (!date) return 'N/A';
        return new Date(date).toLocaleString('en-GB', {
            day: '2-digit',
            month: 'short',
            year: 'numeric',
            hour: '2-digit',
            minute: '2-digit',
            timeZone: 'UTC',
            timeZoneName: 'short'
        });
    }

    function handleSessionExpired() {
        localStorage.removeItem("sessionToken");
        localStorage.removeItem("userId");
        localStorage.removeItem("userEmail");
        updateUserStatus();
        alert("Your session has expired. Please login again.");
    }

    window.showView = function(view) {
        // Handle specific view initializations
        if (view === 'calendar') {
            renderCalendar();
        } else if (view === 'tasks') {
            updateTaskList(localTasks);
        }
    }

    window.openLoginModal = function() {
        document.getElementById("loginModal").classList.remove("hidden");
    }

    function closeLoginModal() {
        document.getElementById("loginModal").classList.add("hidden");
    }

    window.loginUser = function() {
        const email = document.getElementById("emailInput").value;
        const password = document.getElementById("passwordInput").value;
        
        if (!email || !password) {
            alert("Please enter both username and password");
            return;
        }
        
        fetch(`${apiUrl}/login`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ email, password })
        })
        .then(response => {
            if (!response.ok) {
                throw new Error("Login failed");
            }
            return response.json();
        })
        .then(data => {
            authToken = data.token;
            localStorage.setItem("sessionToken", data.token);
            sessionStorage.setItem("sessionToken", data.token);
            
            currentUser = data.userId;
            localStorage.setItem("userId", data.userId);
            localStorage.setItem("userEmail", data.email);

            updateUserStatus();
            closeLoginModal();
            syncTasks();
        })
        .catch(error => {
            alert("Login failed: " + error.message);
        });
    }

    async function updateUserStatus() {
        currentUser = await fetchUserById(localStorage.getItem("userId"));

        if (currentUser) {
            userStatus.textContent = `Logged in as: ${currentUser}`;
            userStatus.classList.add("font-semibold", "text-green-600");
        } else {
            userStatus.textContent = "Not logged in";
            userStatus.classList.remove("font-semibold", "text-green-600");
        }
    }
        
    function getTaskColor(status) {
        switch (status) {
            case "Done": return "#10B981"; // green-500
            case "Ongoing": return "#3B82F6"; // blue-500
            case "Overdue": return "#EF4444"; // red-500
            case "Not Started": return "#6B7280"; // gray-500
            default: return "#9CA3AF"; // gray-400
        }
    }

    async function fetchUserById(userId) {
        try {
            const res = await fetch(`${apiUrl}/user/${userId}`);
            if (!res.ok) throw new Error('User not found');
            const data = await res.json();
            return data.name || userId;
        } catch (err) {
            console.error('Failed to fetch user by ID:', err);
            return userId;
        }
    }

    async function syncTasks() {
        try {
            const token = localStorage.getItem("sessionToken");
            if (!token) {
                console.log("No auth token available. Please login first.");
                return;
            }

            // If we have a token, fetch tasks from server
            try {
                const projects = await fetchUserProjects();
                if (projects && projects.length > 0) {
                    // Initialize a combined tasks array
                    let allTasks = [];
                    
                    // For each project, fetch its tasks
                    for (const project of projects) {
                        try {
                            const tasks = await fetchProjectTasks(project.projectId);
                            if (tasks && tasks.length > 0) {
                                // Add project name to each task
                                const tasksWithProject = tasks.map(task => ({
                                    ...task,
                                    projectName: project.name,
                                    projectId: project.projectId
                                }));
                                allTasks = [...allTasks, ...tasksWithProject];
                            }
                        } catch (err) {
                            console.error(`Error fetching tasks for project ${project.projectId}:`, err);
                        }
                    }
                    
                    // Store all tasks in localStorage for offline use
                    if (allTasks.length > 0) {
                        localTasks = allTasks;
                        localStorage.setItem("tasks", JSON.stringify(localTasks));
                        console.log(`Saved ${allTasks.length} tasks for offline use`);
                    }
                }
            } catch (err) {
                console.error("Error syncing from projects:", err);
            }

            // Update UI with synced tasks
            updateTaskList(localTasks);
            
            // If calendar view is active, re-render it
            if (!document.getElementById("calendarView").classList.contains("hidden")) {
                renderCalendar();
            }
            console.log("Tasks synced successfully");
        } catch (error) {
            console.error("Sync failed:", error);
            alert("Failed to sync tasks with server");
        }
    }

    function updateTaskList(tasks) {
        if (!tasksContainer) return;
        
        // Clear existing tasks
        tasksContainer.innerHTML = "";
        
        if (tasks.length === 0) {
            tasksContainer.innerHTML = "<p class='col-span-3 text-center text-gray-500 py-4'>No tasks available</p>";
            return;
        }
        
        // Add tasks to container
        tasks.forEach(task => {
            const taskCard = document.createElement("div");
            taskCard.className = "bg-white p-4 rounded-lg shadow hover:shadow-md";
            taskCard.innerHTML = `
                <div class="task-card">
                    <div class="flex justify-between items-center mb-3">
                        <h3 class="font-bold text-lg text-gray-800">${task.name}</h3>
                        <span class="px-2 py-1 rounded text-white text-xs" 
                            style="background-color: ${getTaskColor(task.status)}">${task.status}</span>
                    </div>
                
                    <div class="space-y-2 mb-4">
                        <div class="flex items-center text-sm text-gray-600">
                            <i class="fas fa-folder-open mr-2"></i>
                            <span>${task.projectName || 'N/A'}</span>
                        </div>
                            
                        ${task.deliverable ? `
                            <div class="flex items-center text-sm text-gray-600">
                                <i class="fas fa-file-alt mr-2"></i>
                                <span>${task.deliverable}</span>
                            </div>
                        ` : ''}
                            
                        <div class="flex items-center text-sm text-gray-500">
                            <i class="far fa-calendar-alt mr-2"></i>
                            <span>${formatDateUTC(task.startDate)} - ${formatDateUTC(task.endDate)}</span>
                        </div>
                    </div>
                        
                    <div class="flex justify-end mt-4 space-x-2">
                        ${task.status !== 'Done' ? 
                          `<button onclick="markAsDone('${task.projectId}', '${task.taskId}')" 
                                   class="btn btn-emerald-500 text-xs">
                                <i class="fas fa-check mr-1"></i> Mark Done
                            </button>` : ''}
                        <button onclick="deleteTask('${task.projectId}', '${task.taskId}')" 
                                class="btn btn-red-500 text-xs">
                            <i class="fas fa-trash-alt mr-1"></i> Delete
                        </button>
                    </div>
                </div>
            `;
            tasksContainer.appendChild(taskCard);
        });
    }
    
    async function renderCalendar()  {
        const calendarEl = document.getElementById('calendar');
        if (!calendarEl) return;

        // Destroy existing calendar instance if it exists
        if (calendarEl._calendar) {
            calendarEl._calendar.destroy();
        }

        try {
            // In a real scenario, we'd fetch projects and tasks from the server
            // For demo purposes, let's use the local tasks if there are no server tasks
            let allEvents = [];
            
            if (currentUser) {
                try {
                    const projects = await fetchUserProjects();
                    if (projects && projects.length > 0) {
                        for (const project of projects) {
                            const tasks = await fetchProjectTasks(project.projectId) || [];
                                
                            const taskEvents = tasks.map(task => ({
                                id: task.taskId,
                                title: `${task.name} (${project.name})`,
                                start: task.startDate,
                                end: task.endDate,
                                backgroundColor: getTaskColor(task.status),
                                borderColor: getTaskColor(task.status),
                                extendedProps: {
                                    projectName: project.name,
                                    status: task.status,
                                    deliverable: task.deliverable
                                }
                            }));
                            allEvents.push(...taskEvents);
                        }
                    }
                } catch (error) {
                    console.error("Error fetching project data:", error);
                }
            }
            
            // If no server tasks, use local tasks
            if (allEvents.length === 0 && localTasks.length > 0) {
                allEvents = localTasks.map(task => ({
                    id: task.taskId,
                    title: task.name,
                    start: task.startDate,
                    end: task.endDate,
                    backgroundColor: getTaskColor(task.status),
                    borderColor: getTaskColor(task.status),
                    extendedProps: {
                        projectName: task.projectName || 'N/A',
                        status: task.status,
                        deliverable: task.deliverable || 'N/A'
                    }
                }));
            }

            calendar = new FullCalendar.Calendar(calendarEl, {
                initialView: 'dayGridMonth',
                headerToolbar: {
                    left: 'prev,next today',
                    center: 'title',
                    right: 'dayGridMonth,timeGridWeek,timeGridDay'
                },
                events: allEvents,
                eventDidMount: function(info) {
                    info.el.title = `
                        Project: ${info.event.extendedProps.projectName}
                        Status: ${info.event.extendedProps.status}
                    `.trim();
                },
                eventClick: function(info) {
                    const event = info.event;
                    const details = `
                        <div class="p-4">
                            <h3 class="font-bold text-lg mb-4 text-gray-800">${event.title}</h3>
                            
                            <div class="space-y-3">
                                <div class="flex items-center">
                                    <div class="w-24 text-gray-600 font-medium">Project:</div> 
                                    <div>${event.extendedProps.projectName}</div>
                                </div>
                                        
                                <div class="flex items-center">
                                    <div class="w-24 text-gray-600 font-medium">Status:</div>
                                    <div><span class="status-badge text-white px-2 py-1" 
                                        style="background-color: ${getTaskColor(event.extendedProps.status)}">
                                        ${event.extendedProps.status}</span>
                                    </div>
                                </div>
                                        
                                <div class="flex items-center">
                                    <div class="w-24 text-gray-600 font-medium">Deliverable:</div>
                                    <div>${event.extendedProps.deliverable}</div>
                                </div>
                                        
                                <div class="flex items-center">
                                    <div class="w-24 text-gray-600 font-medium">Duration:</div>
                                    <div>${formatDateUTC(event.start)} - ${formatDateUTC(event.end)}</div>
                                </div>
                            </div>
                        </div>
                    `;
                            
                    // Create modal to show task details
                    const modal = document.createElement('div');
                    modal.className = 'fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50';
                    modal.innerHTML = `
                        <div class="relative mx-auto p-5 border w-full max-w-md shadow-lg rounded-md bg-white">
                            <div class="flex justify-between items-center mb-4">
                                <h3 class="text-lg font-medium text-gray-800">Task Details</h3>
                                <button class="text-gray-400 hover:text-gray-500 close-modal">
                                    <i class="fas fa-times"></i>
                                </button>
                            </div>
                            ${details}
                            <div class="text-right mt-6">
                                <button class="btn btn-indigo-600 close-modal">Close</button>
                            </div>
                        </div>
                    `;
                            
                    document.body.appendChild(modal);
                            
                    modal.addEventListener('click', function(e) {
                        if (e.target === modal || e.target.textContent === 'Close') {
                            modal.remove();
                        }
                    });
                },
                height: 'auto'
            });
            calendar.render();
            calendarEl._calendar = calendar;
        
        } catch (error) {
            console.error('Error rendering calendar:', error);
            calendarEl.innerHTML = '<p class="text-red-500 p-4">Error loading calendar. Please try again later.</p>';
        }
    }

    async function fetchUserProjects() {
        const token = localStorage.getItem("sessionToken");
        
        try {
            const response = await fetch(`${apiUrl}/user-projects`, {
                headers: {
                    'Authorization': `Bearer ${token}`
                }
            });

            if (response.status === 401) {
                handleSessionExpired();
                return;
            }

            if (!response.ok) {
                const text = await response.text();
                console.error('Server responded with error:', response.status, text);
                return;
            }

            const data = await response.json();
            return data.projects;
        } catch (error) {
            console.error('Error fetching projects:', error);
        }
    }

    async function fetchProjectTasks(projectId) {
        const token = localStorage.getItem("sessionToken");

        try {
            const response = await fetch(`${apiUrl}/projects/${projectId}/tasks`, {
                headers: {
                    'Authorization': `Bearer ${token}`
                }
            });

            if (response.status === 401) {
                handleSessionExpired();
                return;
            }

            const data = await response.json();

            const tasksWithStringDates = data.tasks.map(task => ({
                ...task,
                startDate: task.startDate ? new Date(task.startDate._seconds * 1000).toISOString() : null,
                endDate: task.endDate ? new Date(task.endDate._seconds * 1000).toISOString() : null
            }));
            
            return tasksWithStringDates;
        } catch (error) {
            console.error('Error fetching tasks:', error);
        }
    }

    window.markAsDone=  async function(projectId, taskId) {
        try {
            const response = await fetch(`${apiUrl}/projects/${projectId}/update-task/${taskId}/status`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${localStorage.getItem("sessionToken")}`
                },
                body: JSON.stringify({ status: 'Done' })
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || 'Failed to update task status');
            }

            alert('Task marked as done!');
            syncTasks();
        } catch (error) {
            console.error('Error marking task as done:', error);
            alert('Failed to mark task as done');
        }
    }

    window.deleteTask = async function(projectId, taskId) {
        try {
            const response = await fetch(`${apiUrl}/projects/${projectId}/delete-task/${taskId}`, {
                method: 'DELETE',
                headers: {
                    'Authorization': `Bearer ${localStorage.getItem("sessionToken")}`
                }
            });
            console.log('Deleting task from project:', projectId, taskId);

            if (response.ok) {
                alert('Task deleted successfully');
                await renderProjectsAndTasks();
            } else {
                const data = await response.json();
                alert('Error deleting task: ' + data.error);
            }
        } catch (error) {
            console.error('Error:', error);
            alert('Failed to delete task.');
        }
    }
       
    function connectWebSocket() {
        try {
            socket = new WebSocket(wsUrl);
            
            socket.onopen = () => {
                console.log("ðŸ”— WebSocket connected");
                connectionStatus.textContent = "Online";
                connectionStatus.classList.replace("bg-red-500", "bg-green-500");
                isOffline = false;
                
                if (authToken) {
                    socket.send(JSON.stringify({ type: "auth", token: authToken }));
                }
                
                // Try to sync tasks when connection is established
                if (authToken) {
                    syncTasks().catch(err => console.error("Auto-sync failed:", err));
                }
            };
            
            socket.onmessage = (event) => {
                const data = JSON.parse(event.data);
                if (data.type === "new_task") {
                    // Add the new task to local storage
                    localTasks.push(data.task);
                    localStorage.setItem("tasks", JSON.stringify(localTasks));
                    updateTaskList(localTasks);
                    
                    // Only add the event if calendar is initialized
                    if (calendar) {
                        calendar.addEvent({
                            id: data.task.taskId,
                            title: data.task.name,
                            start: data.task.startDate,
                            end: data.task.endDate,
                            backgroundColor: getTaskColor(data.task.status),
                            borderColor: getTaskColor(data.task.status),
                            extendedProps: {
                                projectName: data.task.projectName || 'N/A',
                                status: data.task.status,
                                deliverable: data.task.deliverable || 'N/A'
                            }
                        });
                    }
                } else if (data.type === "task_updated") {
                    // Update task in local storage
                    const index = localTasks.findIndex(t => t.taskId === data.task.taskId);
                    if (index !== -1) {
                        localTasks[index] = {...localTasks[index], ...data.task};
                        localStorage.setItem("tasks", JSON.stringify(localTasks));
                        updateTaskList(localTasks);
                        
                        // Update calendar if it's initialized
                        if (calendar) {
                            const existingEvent = calendar.getEventById(data.task.taskId);
                            if (existingEvent) {
                                existingEvent.remove();
                            }
                            calendar.addEvent({
                                id: data.task.taskId,
                                title: data.task.name,
                                start: data.task.startDate,
                                end: data.task.endDate,
                                backgroundColor: getTaskColor(data.task.status),
                                borderColor: getTaskColor(data.task.status),
                                extendedProps: {
                                    projectName: data.task.projectName || 'N/A',
                                    status: data.task.status,
                                    deliverable: data.task.deliverable || 'N/A'
                                }
                            });
                        }
                    }
                } else if (data.type === "task_deleted") {
                    // Remove task from local storage
                    const index = localTasks.findIndex(t => t.taskId === data.taskId);
                    if (index !== -1) {
                        localTasks.splice(index, 1);
                        localStorage.setItem("tasks", JSON.stringify(localTasks));
                        updateTaskList(localTasks);
                        
                        // Remove from calendar if it's initialized
                        if (calendar) {
                            const existingEvent = calendar.getEventById(data.taskId);
                            if (existingEvent) {
                                existingEvent.remove();
                            }
                        }
                    }
                } else if (data.type === "auth_success") {
                    console.log("âœ… WebSocket authenticated");
                }
            };
            
            socket.onclose = () => {
                console.log("âŒ WebSocket disconnected");
                connectionStatus.textContent = "Offline";
                connectionStatus.classList.replace("bg-green-500", "bg-red-500");
                isOffline = true;
                
                // Use cached tasks when offline
                updateTaskList(localTasks);
                
                // Try to reconnect
                setTimeout(connectWebSocket, 3000);
            };
            
            socket.onerror = (error) => {
                console.error("WebSocket Error:", error);
                isOffline = true;
                connectionStatus.textContent = "Offline";
                connectionStatus.classList.replace("bg-green-500", "bg-red-500");
            };
        } catch (error) {
            console.error("Failed to create WebSocket connection:", error);
            isOffline = true;
            connectionStatus.textContent = "Offline";
            connectionStatus.classList.replace("bg-green-500", "bg-red-500");
            
            // Use cached tasks when offline
            updateTaskList(localTasks);
            
            // Try to reconnect
            setTimeout(connectWebSocket, 5000);
        }
    }

    // Set up event listeners
    syncButton.addEventListener("click", syncTasks);
    
    // Initialize
    updateUserStatus();
    connectWebSocket();
    
    // Show calendar view by default
    showView('calendar');
});
    </script>
</body>
</html>